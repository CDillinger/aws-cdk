import { Lazy, Names, Resource, Tags } from 'aws-cdk-lib';
import {
  CfnSubnet,
  CfnSubnetRouteTableAssociation,
  INetworkAcl,
  IRouteTable,
  ISubnet,
  NetworkAcl,
  SubnetNetworkAclAssociation,
  SubnetType,
} from 'aws-cdk-lib/aws-ec2';
import { Construct, DependencyGroup, IDependable } from 'constructs';
import { IVpcV2 } from './vpc-v2-base';
import { CidrBlock, CidrBlockIpv6 } from './util';
import { RouteTable } from './route';
import { IIpamPool } from './ipam';

/**
 * Interface to define subnet CIDR
 */
interface ICidr {
  readonly cidr: string;
}

/**
 * IPv4 or IPv6 CIDR range for the subnet
 */
export class IpCidr implements ICidr {

  /**
  * IPv6 CIDR range for the subnet
  * Allowed only if IPv6 is enabled on VPc
  */
  public readonly cidr: string;
  constructor(props: string ) {
    this.cidr = props;
  }
}

/**
 * Define Cidr with Ipam Option.
 * */
interface CidrIpamOption {
  readonly ipamPool: IIpamPool;
  readonly netmaskLength: number;
}

/**
 * SubnetV2CidrOption could be either ICidr or CidrIpamOption.
 * */
export interface SubnetV2CidrOption {
  /**
   * The CIDR block in string format
   *
   * @default - undefined
   */
  readonly cidr?: string;

  /**
   * The associated IIpamPool
   *
   * @default - undefined
   */
  readonly ipamPool?: IIpamPool;

  /**
   * The associated IIpamPool netmaskLength
   *
   * @default - undefined
   */
  readonly netmaskLength?: number;
}

/**
 * Name tag constant
 */
const NAME_TAG: string = 'Name';

/**
 * VPC Name tag constant
 */
const VPCNAME_TAG: string = 'VpcName';

/**
 * Properties to define subnet for VPC.
 */
export interface SubnetV2Props {
  /**
   * VPC Prop
   */
  readonly vpc: IVpcV2;

  /**
   * IPv4 CIDR to assign to this subnet.
   * See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-cidrblock
   * @default - No IPv4 CIDR is provided
   */
  readonly ipv4Cidr?: SubnetV2CidrOption;

  /**
   * IPv6 CIDR Range for subnet
   *
   * @default - No Ipv6 address
   */
  readonly ipv6Cidr?: SubnetV2CidrOption;

  /**
   * Custom AZ for the subnet
   */
  readonly availabilityZone: string;

  /**
   * Custom Route for subnet
   *
   * @default - a default route table created
   */
  readonly routeTable?: IRouteTable;

  /**
   * The type of Subnet to configure.
   *
   * The Subnet type will control the ability to route and connect to the
   * Internet.
   *
   * TODO: Add validation check `subnetType` when adding resources (e.g. cannot add NatGateway to private)
   */
  readonly subnetType: SubnetType;

  /**
   * Subnet name
   *
   * @default - provisioned with an autogenerated name by CDK
   */
  readonly subnetName?: string;

  /**
   * Indicates whether a network interface created in this subnet receives an IPv6 address.
   * If you specify AssignIpv6AddressOnCreation, you must also specify Ipv6CidrBlock.
   *
   * @default - undefined in case not provided as an input
   */
  readonly assignIpv6AddressOnCreation?: boolean;

}

/**
 * Interface with additional properties for SubnetV2
 */
export interface ISubnetV2 extends ISubnet {

  /**
   * The IPv4 CIDR block for this subnet
   * */
  readonly ipv4Cidr?: SubnetV2CidrOption;

  /**
   * The IPv6 CIDR block for this subnet
   */
  readonly ipv6Cidr?: SubnetV2CidrOption;

  /**
   * The type of subnet (public or private) that this subnet represents.
   *
   * @attribute SubnetType
   */
  readonly subnetType?: SubnetType;

}

/**
 * The SubnetV2 class represents a subnet within a VPC (Virtual Private Cloud) in AWS.
 * It extends the Resource class and implements the ISubnet interface.
 *
 * Instances of this class can be used to create and manage subnets within a VpcV2 instance.
 * Subnets can be configured with specific IP address ranges (IPv4 and IPv6), availability zones,
 * and subnet types (e.g., public, private, isolated).
 *
 * @resource AWS::EC2::Subnet
 *
 */
export class SubnetV2 extends Resource implements ISubnetV2 {

  /**
   * Import an existing subnet to the VPC
   */
  public static fromSubnetV2Attributes(scope: Construct, id: string, attrs: SubnetV2Attributes) : ISubnetV2 {
    /**
    * Class to define an import for an existing subnet
    * @resource AWS::EC2::Subnet
    */
    class ImportedSubnetV2 extends Resource implements ISubnetV2 {
      public readonly ipv4Cidr?: SubnetV2CidrOption = importCidrFrom({
        cidr: attrs.ipv4CidrBlock,
        ipamPool: attrs.ipv4IpamPool,
        netmaskLength: attrs.ipv4NetmaskLength,
      });

      /**
      * The IPv6 CIDR Block assigned to this subnet
      */
      public readonly ipv6Cidr?: SubnetV2CidrOption = importCidrFrom({
        cidr: attrs.ipv6CidrBlock,
        ipamPool: attrs.ipv6IpamPool,
        netmaskLength: attrs.ipv6NetmaskLength,
      });

      /**
      * The type of subnet (eg. public or private) that this subnet represents.
      */
      public readonly subnetType?: SubnetType = attrs.subnetType;

      /**
      * The Availability Zone in which subnet is located
      */
      public readonly availabilityZone: string = attrs.availabilityZone;

      /**
      * The subnetId for this particular subnet
      * Refers to the physical ID created
      */
      public readonly subnetId: string = attrs.subnetId;

      /**
      * Dependable that can be depended upon to force internet connectivity established on the VPC
      */
      public readonly internetConnectivityEstablished: IDependable = new DependencyGroup();

      /**
      *  Current route table associated with this subnet
      */
      public readonly routeTable: IRouteTable = { routeTableId: attrs.routeTableId! };

      public get ipv4CidrBlock(): string {
        if (isICidr(this.ipv4Cidr)) {
          return this.ipv4Cidr.cidr;
        }

        throw new Error(`
        Unable to derive the ipv4CidrBlock from the ipv4Cidr. 
        Please verify that the correct ipv4Cidr confirm to the ICidr interface.
        `);
      }

      /**
      * Associate a Network ACL with this subnet
      * Required here since it is implemented in the ISubnetV2
      */
      public associateNetworkAcl(aclId: string, networkAcl: INetworkAcl) {
        const aclScope = networkAcl instanceof Construct ? networkAcl : this;
        const other = networkAcl instanceof Construct ? this : networkAcl;
        new SubnetNetworkAclAssociation(aclScope, aclId + Names.nodeUniqueId(other.node), {
          networkAcl,
          subnet: this,
        });
      }
    }

    return new ImportedSubnetV2(scope, id);
  }

  /**
   * The Availability Zone the subnet is located in
   */
  public readonly availabilityZone: string;

  /**
   * The subnetId for this particular subnet
   * @attribute
   */
  public readonly subnetId: string;

  /**
   *  Dependencies for internet connectivity
   * This Property exposes the RouteTable-Subnet association so that other resources can depend on it.
   */
  public readonly internetConnectivityEstablished: IDependable;

  /**
   * The variable name `internetConnectivityEstablished` does not reflect what it actually is.
   * The naming is enforced by ISubnet. We need to keep it to maintain compatibility.
   * It exposes the RouteTable-Subnet association so that other resources can depend on it.
   * E.g. Resources in a subnet, when being deleted, may need the RouteTable to exist in order to delete properly
   */
  private readonly _internetConnectivityEstablished = new DependencyGroup();

  /**
   * The IPv4 CIDR for this subnet
   * */
  public readonly ipv4Cidr?: SubnetV2CidrOption;

  /**
   * The IPv6 CIDR for this subnet
   */
  public readonly ipv6Cidr?: SubnetV2CidrOption;

  /**
   * The type of subnet (public or private) that this subnet represents.
   * @attribute SubnetType
   */
  public readonly subnetType?: SubnetType;

  private _networkAcl: INetworkAcl;

  private _routeTable: IRouteTable;

  /**
   * Constructs a new SubnetV2 instance.
   * @param scope The parent Construct that this resource will be part of.
   * @param id The unique identifier for this resource.
   * @param props The configuration properties for the subnet.
   */
  constructor(scope: Construct, id: string, props: SubnetV2Props) {
    super(scope, id, {
      physicalName: props.subnetName ?? Lazy.string({
        produce: () => Names.uniqueResourceName(this, { maxLength: 128, allowedSpecialCharacters: '_' }),
      }),
    });

    let validationError = validateIpAddressBlocks(props);
    if (validationError != null) {
      throw validationError;
    }

    const subnet = new CfnSubnet(this, 'Subnet', {
      vpcId: props.vpc.vpcId,
      cidrBlock: asICidr(props.ipv4Cidr)?.cidr,
      ipv4IpamPoolId: asCidrIpamOption(props.ipv4Cidr)?.ipamPool.ipamPoolId,
      ipv4NetmaskLength: asCidrIpamOption(props.ipv4Cidr)?.netmaskLength,
      ipv6CidrBlock: asICidr(props.ipv6Cidr)?.cidr,
      ipv6IpamPoolId: asCidrIpamOption(props.ipv6Cidr)?.ipamPool.ipamPoolId,
      ipv6NetmaskLength: asCidrIpamOption(props.ipv6Cidr)?.netmaskLength,
      availabilityZone: props.availabilityZone,
      assignIpv6AddressOnCreation: props.assignIpv6AddressOnCreation ?? false,
    });

    this.node.defaultChild = subnet;
    this.ipv4Cidr = props.ipv4Cidr;
    this.ipv6Cidr = props.ipv6Cidr;
    this.subnetId = subnet.ref;
    this.availabilityZone = props.availabilityZone;

    this._networkAcl = NetworkAcl.fromNetworkAclId(this, 'Acl', subnet.attrNetworkAclAssociationId);

    if (props.subnetName) {
      Tags.of(this).add(NAME_TAG, props.subnetName);
    }

    if (props.vpc.vpcName) {
      Tags.of(this).add(VPCNAME_TAG, props.vpc.vpcName);
    }

    if (props.routeTable) {
      this._routeTable = props.routeTable;
    } else {
      // Assigning a default route table
      this._routeTable = new RouteTable(this, 'RouteTable', {
        vpc: props.vpc,
        routeTableName: 'DefaultCDKRouteTable',
      });
    }

    const routeAssoc = new CfnSubnetRouteTableAssociation(this, 'RouteTableAssociation', {
      subnetId: this.subnetId,
      routeTableId: this.routeTable.routeTableId,
    });

    this._internetConnectivityEstablished.add(routeAssoc);

    this.internetConnectivityEstablished = this._internetConnectivityEstablished;

    this.subnetType = props.subnetType;
    storeSubnetToVpcByType(props.vpc, this, props.subnetType);
  }

  /**
   * Associate a Network ACL with this subnet
   *
   * @param id The unique identifier for this association.
   * @param networkAcl The Network ACL to associate with this subnet.
   * This allows controlling inbound and outbound traffic for instances in this subnet.
   */
  public associateNetworkAcl(id: string, networkAcl: INetworkAcl) {
    this._networkAcl = networkAcl;

    const scope = networkAcl instanceof Construct ? networkAcl : this;
    const other = networkAcl instanceof Construct ? this : networkAcl;
    new SubnetNetworkAclAssociation(scope, id + Names.nodeUniqueId(other.node), {
      networkAcl,
      subnet: this,
    });
  }

  /**
   * Return the Route Table associated with this subnet
   */
  public get routeTable(): IRouteTable {
    return this._routeTable;
  }

  /**
   * Returns the Network ACL associated with this subnet.
   */

  public get networkAcl(): INetworkAcl {
    return this._networkAcl;
  }

  /**
   * Computed property for the ipv4CidrBlock of ISubnet
   * @returns The ipv4CidrBlock if provided one.
   * @throws When ipv4Cidr is not in ICidr shape.
   * */
  public get ipv4CidrBlock(): string {
    if (isICidr(this.ipv4Cidr)) {
      return this.ipv4Cidr.cidr;
    }

    throw new Error(`
    Unable to derive the ipv4CidrBlock from the SubnetV2::ipv4Cidr. 
    Please verify that the ipv4Cidr confirm to the ICidr interface.
    `);
  }
}

/**
 * Properties required to import a subnet
 */
export interface SubnetV2Attributes {
  /**
   * The Availability Zone this subnet is located in
   *
   * @default - No AZ information, cannot use AZ selection features
   */
  readonly availabilityZone: string;

  /**
   * The IPv4 CIDR block associated with the subnet
   *
   * @default - No CIDR information, cannot use CIDR filter features
   */
  readonly ipv4CidrBlock?: string;

  /**
   * The associated IPv4 IpamPool ID
   *
   * @default - undefined
   */
  readonly ipv4IpamPool?: IIpamPool;

  /**
   * The associated IPv4 IpamPool netmask length
   *
   * @default - undefined
   */
  readonly ipv4NetmaskLength?: number;

  /**
   * The IPv6 CIDR block associated with the subnet
   *
   * @default - No CIDR information, cannot use CIDR filter features
   */
  readonly ipv6CidrBlock?: string;

  /**
   * The associated IPv6 IpamPool ID
   *
   * @default - undefined
   */
  readonly ipv6IpamPool?: IIpamPool;

  /**
   * The associated IPv6 IpamPool netmask length
   *
   * @default - undefined
   */
  readonly ipv6NetmaskLength?: number;

  /**
   * The ID of the route table for this particular subnet
   *
   * @default - No route table information, cannot create VPC endpoints
   */
  readonly routeTableId?: string;

  /**
   * The subnetId for this particular subnet
   */
  readonly subnetId: string;

  /**
   * The type of subnet (public or private) that this subnet represents.
   */
  readonly subnetType: SubnetType;

  /**
   * Name of the given subnet
   *
   * @default - no subnet name
   */
  readonly subnetName?: string;

}

const subnetTypeMap = {
  [SubnetType.PRIVATE_ISOLATED]: (vpc: IVpcV2, subnet: SubnetV2) => vpc.isolatedSubnets.push(subnet),
  [SubnetType.PUBLIC]: (vpc: IVpcV2, subnet: SubnetV2) => vpc.publicSubnets.push(subnet),
  [SubnetType.PRIVATE_WITH_EGRESS]: (vpc: IVpcV2, subnet: SubnetV2) => vpc.privateSubnets.push(subnet),
  [SubnetType.ISOLATED]: (vpc: IVpcV2, subnet: SubnetV2) => vpc.isolatedSubnets.push(subnet),
  [SubnetType.PRIVATE]: (vpc: IVpcV2, subnet: SubnetV2) => vpc.privateSubnets.push(subnet),
  [SubnetType.PRIVATE_WITH_NAT]: (vpc: IVpcV2, subnet: SubnetV2) => vpc.privateSubnets.push(subnet),
};

/**
 * Stores the provided subnet in the VPC's collection of subnets based on the specified subnet type.
 *
 * @param vpc The VPC instance to which the subnet belongs.
 * @param subnet The subnet instance to be stored.
 * @param type The type of the subnet (e.g., public, private, isolated).
 * @internal
 */
function storeSubnetToVpcByType(vpc: IVpcV2, subnet: SubnetV2, type: SubnetType) {
  const findFunctionType = subnetTypeMap[type];
  if (findFunctionType) {
    findFunctionType(vpc, subnet);
  } else {
    throw new Error(`Unsupported subnet type: ${type}`);
  }

  /**
   * Need to set explicit dependency as during stack deletion,
   * the cidr blocks may get deleted first and will fail as the subnets are still using the cidr blocks
   */
  if (vpc.secondaryCidrBlock) {
    for (const cidr of vpc.secondaryCidrBlock) {
      subnet.node.addDependency(cidr);
    }
  }
}

/**
 * Validates whether the provided VPC supports IPv6 addresses.
 *
 * @param vpc The VPC instance to be validated.
 * @throws Error if the VPC does not support IPv6 addresses.
 * @returns True if the VPC supports IPv6 addresses, false otherwise.
 * @internal
 */
function validateSupportIpv6(vpc: IVpcV2): Error | undefined {
  if (vpc.secondaryCidrBlock) {
    if (!vpc.secondaryCidrBlock.some((secondaryAddress) => secondaryAddress.amazonProvidedIpv6CidrBlock === true ||
  secondaryAddress.ipv6IpamPoolId != undefined)) {
      return new Error('To use IPv6, the VPC must enable IPv6 support.');
    }
  }
  return undefined;
}

/**
 * Checks if the provided CIDR range falls within the IP address ranges of the given VPC.
 *
 * @param vpc The VPC instance to check against.
 * @param cidr The IPv4 CIDR range to be checked.
 * @returns True if the CIDR range falls within the VPC's IP address ranges, false otherwise.
 * @internal
 */
function checkIpv4CidrRanges(vpc: IVpcV2, cidr: SubnetV2Props['ipv4Cidr']): Error | undefined {
  if (!isICidr(cidr)) {
    return undefined;
  }
  const vpcCidrBlock = [vpc.ipv4CidrBlock];
  const subnetCidrBlock = new CidrBlock(cidr.cidr);
  const allCidrs: CidrBlock[] = [];

  // Secondary IP addresses associated using user defined IPv4 range
  if (vpc.secondaryCidrBlock) {
    for (const ipAddress of vpc.secondaryCidrBlock) {
      if (ipAddress.cidrBlock) {
        vpcCidrBlock.push(ipAddress.cidrBlock);
      }
    }
    const cidrs = vpcCidrBlock.map(x => new CidrBlock(x));
    allCidrs.push(...cidrs);
  }

  // If no IPv4 is assigned as secondary address
  if (allCidrs.length === 0) {
    return new Error('No secondary IP address attached to VPC');
  }

  if (!allCidrs.some(c => c.containsCidr(subnetCidrBlock))) {
    return new Error('CIDR block should be within the range of VPC');
  }
  return undefined;
}

const allSubnetsOfVpc = (vpc: IVpcV2): ISubnetV2[] => {
  try {
    return vpc.selectSubnets().subnets;
  } catch (e) {
    return [];
  }
};

/**
 * Validates if the provided IPv4 CIDR block overlaps with existing subnet CIDR blocks within the given VPC.
 *
 * @param vpc The VPC instance to check against.
 * @param cidr The IPv4 address block to be validated.
 * @returns True if the IPv4 CIDR block overlaps with existing subnet CIDR blocks, false otherwise.
 * @internal
 */
const validateOverlappingCidrRangesIpv4 = (
  vpc: IVpcV2,
  cidr: SubnetV2Props['ipv4Cidr'],
): Error | undefined => {
  if (!isICidr(cidr)) {
    return undefined;
  }

  const allSubnets = allSubnetsOfVpc(vpc);
  if (allSubnets.length === 0) return undefined;
  const newCidr = new CidrBlock(cidr.cidr);
  const validCidrs = allSubnets.flatMap(x => isICidr(x.ipv4Cidr) ? [new CidrBlock(x.ipv4Cidr.cidr)] : []);
  const isOverlapped = validCidrs.reduce((p, c) => p || CidrBlock.rangesOverlap(c, newCidr), false);
  if (isOverlapped) {
    return new Error('CIDR block should not overlap with existing subnet blocks');
  }

  return undefined;
};

/**
 * Validates if the provided IPv4 CIDR block overlaps with existing subnet CIDR blocks within the given VPC.
 *
 * @param vpc The VPC instance to check against.
 * @param cidr The IPv6 address block to be validated.
 * @returns True if the IPv6 CIDR block overlaps with existing subnet CIDR blocks, false otherwise.
 * @internal
 */
const validateOverlappingCidrRangesIpv6 = (
  vpc: IVpcV2,
  cidr: SubnetV2Props['ipv6Cidr'],
): Error | undefined => {
  if (!isICidr(cidr)) {
    return undefined;
  }

  const allSubnets = allSubnetsOfVpc(vpc);
  if (allSubnets.length === 0) return undefined;
  const newCidr = new CidrBlockIpv6(cidr.cidr);
  const validCidrs = allSubnets.flatMap(x => isICidr(x.ipv6Cidr) ? [new CidrBlockIpv6(x.ipv6Cidr.cidr)] : []);
  const isOverlapped = validCidrs.reduce((p, c) => p || CidrBlockIpv6.rangesOverlap(c, newCidr), false);
  if (isOverlapped) {
    return new Error('CIDR block should not overlap with existing subnet blocks');
  }

  return undefined;
};

/**
 * Check whether value confirms to ICidr
 * */
function isICidr(value: any): value is ICidr {
  return value != null && typeof value.cidr === 'string';
}

/**
 * Check whether value confirms to CidrIpamOption
 * */
function isCidrIpamOption(value: any): value is CidrIpamOption {
  return value != null && typeof value.netmaskLength === 'number' && value.ipamPool != null;
}

/**
 * Converts value to Optional<ICidr>
 * */
const asICidr = (value: any): ICidr | undefined => isICidr(value) ? value : undefined;
/**
 * Converts value to Optional<CidrIpamOption>
 * */
const asCidrIpamOption = (value: any): CidrIpamOption | undefined => isCidrIpamOption(value) ? value : undefined;

/**
 * Validate SubnetV2Props has correct cidrs provided.
 * @param props The SubnetV2Props.
 * @returns Error will be returned if incorrect cidr is provided.
 * */
const validateIpAddressBlocks = (props: SubnetV2Props): Error | undefined => {
  const { ipv4Cidr, ipv6Cidr, vpc, assignIpv6AddressOnCreation } = props;
  if (ipv4Cidr == null && ipv6Cidr == null) {
    return new Error('An ipv4Cidr or ipv6Cidr option must be provided.');
  }

  if (assignIpv6AddressOnCreation && !ipv6Cidr) {
    return new Error('IPv6 CIDR block is required when assigning IPv6 address on creation');
  }

  if (ipv4Cidr != null) {
    const error = checkIpv4CidrRanges(vpc, ipv4Cidr) ?? validateOverlappingCidrRangesIpv4(vpc, ipv4Cidr);
    if (error != null) return error;
  }

  if (ipv6Cidr != null) {
    const error = validateSupportIpv6(vpc) ?? validateOverlappingCidrRangesIpv6(vpc, ipv6Cidr);
    if (error != null) return error;
  }

  return undefined;
};

/**
 * Create SubnetV2CidrOption from attributes for both ipv4 and ipv6.
 * */
const importCidrFrom = (props: {
  cidr?: string;
  ipamPool?: IIpamPool;
  netmaskLength?: number;
}): SubnetV2CidrOption | undefined => {
  const {
    cidr,
    ipamPool,
    netmaskLength,
  } = props;
  if (cidr == null) {
    if (ipamPool != null) {
      return { ipamPool, netmaskLength };
    }
  } else if (ipamPool == null) {
    return { cidr: cidr };
  }

  return undefined;
};
